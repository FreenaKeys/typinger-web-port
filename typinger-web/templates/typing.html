<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typinger - ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <h1>Typinger</h1>
            <p class="subtitle">Webç‰ˆ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ã‚½ãƒ•ãƒˆ</p>
        </header>

        <main>
            <!-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”»é¢ -->
            <section id="typing-screen" class="screen active">
                <div class="typing-container">
                    <!-- ã‚­ãƒ¼ãƒãƒƒãƒ—è¨­å®š + ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                    <div class="keymap-setting" style="margin-bottom: 20px; padding: 15px; background: #f0f0f0; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 15px;">
                            <div style="flex: 1;">
                                <label for="keymap-select" style="display: block; margin-bottom: 10px; font-weight: bold;">
                                    âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰é…åˆ—:
                                </label>
                                <select id="keymap-select" style="width: 100%; padding: 8px; font-size: 14px; border-radius: 4px;">
                                    <option value="jis">JISé…åˆ— (æ—¥æœ¬èª)</option>
                                    <option value="ansi">ANSIé…åˆ—</option>
                                    <option value="dvorak">Dvoraké…åˆ—</option>
                                </select>
                                <p id="keymap-info" style="margin-top: 10px; font-size: 12px; color: #666;">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: JISé…åˆ—</p>
                            </div>
                            <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                            <div id="custom-mapping-preview" style="flex: 0 0 auto; padding: 10px; background: white; border-radius: 4px; border: 1px solid #bdc3c7; min-width: 200px; display: none;">
                                <p style="margin: 0 0 8px 0; font-size: 11px; font-weight: bold; color: #2c3e50;">ğŸ¯ ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°</p>
                                <div id="preview-mappings" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                    <!-- ãƒãƒƒãƒ”ãƒ³ã‚°ãŒè¡¨ç¤ºã•ã‚Œã‚‹ -->
                                </div>
                                <button id="btn-edit-mapping" style="padding: 4px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px; width: 100%;">
                                    ç·¨é›†
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ãƒãƒƒãƒ”ãƒ³ã‚°ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
                    <div id="mapping-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; padding: 20px;">
                        <div style="background: white; border-radius: 8px; padding: 20px; max-width: 500px; margin: 50px auto; max-height: 80vh; overflow-y: auto;">
                            <h3 style="margin-top: 0;">ğŸ¯ ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ç·¨é›†</h3>
                            <div id="edit-mapping-items" style="margin-bottom: 20px;">
                                <!-- ç·¨é›†ã‚¢ã‚¤ãƒ†ãƒ ãŒè¡¨ç¤ºã•ã‚Œã‚‹ -->
                            </div>
                            <button id="btn-close-modal" style="width: 100%; padding: 10px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                âœ“ é–‰ã˜ã‚‹
                            </button>
                        </div>
                    </div>

                    <!-- ç›®æ¨™ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º -->
                    <div class="target-text-box">
                        <p class="label">ç›®æ¨™ãƒ†ã‚­ã‚¹ãƒˆ</p>
                        <p id="target-text" class="target-text">{{ target_text }}</p>
                    </div>

                    <!-- ãƒ«ãƒ“ï¼ˆãƒ­ãƒ¼ãƒå­—ï¼‰è¡¨ç¤º -->
                    <div class="rubi-box">
                        <p class="label">ãƒ­ãƒ¼ãƒå­—å…¥åŠ›</p>
                        <p id="rubi-remaining" class="rubi-remaining" style="min-height: 30px;">{{ target_rubi }}</p>
                        <p id="rubi-progress" style="font-size: 12px; color: #e74c3c; margin-top: 5px;"></p>
                    </div>

                    <!-- å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ -->
                    <div class="input-box">
                        <p style="font-size: 12px; color: #666; margin-bottom: 8px;">
                            ç¾åœ¨ã®ã‚­ãƒ¼ãƒãƒƒãƒ—: <span id="current-keymap-display">JISé…åˆ—</span>
                        </p>
                        <input type="text" id="typing-input" class="typing-input" placeholder="ã“ã“ã«å…¥åŠ›ã—ã¾ã™" autofocus>
                    </div>

                    <!-- çµ±è¨ˆæƒ…å ± -->
                    <div class="stats-box">
                        <table class="stats-table">
                            <tr>
                                <td>æ­£è§£:</td>
                                <td id="stat-correct">0</td>
                                <td>ãƒŸã‚¹:</td>
                                <td id="stat-errors">0</td>
                            </tr>
                            <tr>
                                <td>æˆåŠŸç‡:</td>
                                <td id="stat-accuracy">0%</td>
                                <td>çµŒéæ™‚é–“:</td>
                                <td id="stat-time">0s</td>
                            </tr>
                        </table>
                    </div>

                    <!-- æ“ä½œãƒœã‚¿ãƒ³ -->
                    <div class="button-box">
                        <button id="btn-finish" class="btn btn-primary">å®Œäº†</button>
                        <button id="btn-escape" class="btn btn-secondary">ä¸­æ­¢</button>
                    </div>
                </div>
            </section>

            <!-- çµæœç”»é¢ -->
            <section id="result-screen" class="screen hidden">
                <div class="typing-container">
                    <h2>å®Œäº†ã—ã¾ã—ãŸï¼</h2>
                    <div class="result-box">
                        <table class="result-table">
                            <tr>
                                <td>æ­£è§£æ•°:</td>
                                <td id="result-correct">0</td>
                            </tr>
                            <tr>
                                <td>ãƒŸã‚¹æ•°:</td>
                                <td id="result-errors">0</td>
                            </tr>
                            <tr>
                                <td>æˆåŠŸç‡:</td>
                                <td id="result-accuracy">0%</td>
                            </tr>
                            <tr>
                                <td>æ‰€è¦æ™‚é–“:</td>
                                <td id="result-duration">0ç§’</td>
                            </tr>
                        </table>
                    </div>
                    <div class="button-box">
                        <button id="btn-home" class="btn btn-primary">ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
                    </div>
                </div>
            </section>
        </main>

        <footer>
            <p>Typinger Webç‰ˆ - ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ã‚½ãƒ•ãƒˆ</p>
        </footer>
    </div>

    <script>
        // ========== ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ==========
        const SESSION_ID = '{{ session_id }}';
        const TARGET_TEXT = '{{ target_text }}';
        const TARGET_RUBI = '{{ target_rubi }}';
        
        let startTime = Date.now();
        let correct = 0;
        let errors = 0;
        let currentProgress = '';
        let currentKeymap = 'jis';
        let keymapData = null;
        let editingKey = null;
        let editingValue = null;

        console.log('ğŸ¬ Typing page loaded');
        console.log('  Session ID:', SESSION_ID);
        console.log('  Target Text:', TARGET_TEXT);
        console.log('  Target Rubi:', TARGET_RUBI);

        // ========== ã‚­ãƒ¼ãƒãƒƒãƒ—å‡¦ç† ==========
        async function loadKeymap(preset) {
            try {
                console.log(`âŒ¨ï¸ Loading keymap: ${preset}`);
                
                // ãƒ—ãƒªã‚»ãƒƒãƒˆã‹ã‚«ã‚¹ã‚¿ãƒ ã‹ã‚’åˆ¤å®š
                let response;
                if (['jis', 'ansi', 'dvorak'].includes(preset)) {
                    response = await fetch(`/api/keymap/presets/${preset}`);
                } else {
                    // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—
                    response = await fetch(`/api/keymap/${preset}`);
                }
                
                const data = await response.json();
                
                if (data.ok) {
                    keymapData = data.keymap;
                    currentKeymap = preset;
                    
                    const presetNames = {
                        'jis': 'JISé…åˆ— (æ—¥æœ¬èª)',
                        'ansi': 'ANSIé…åˆ—',
                        'dvorak': 'Dvoraké…åˆ—'
                    };
                    
                    const displayName = presetNames[preset] || preset;
                    document.getElementById('keymap-info').textContent = `âœ… ä½¿ç”¨ä¸­: ${displayName}`;
                    console.log(`âœ… Keymap loaded: ${preset}`, keymapData);
                } else {
                    console.error('âŒ Failed to load keymap:', data.error);
                }
            } catch (error) {
                console.error('âŒ Error loading keymap:', error);
            }
        }

        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã‚’ã‚»ãƒ¬ã‚¯ãƒˆã«è¿½åŠ 
        async function loadCustomKeymaps() {
            try {
                console.log('ğŸ“‚ Loading custom keymaps...');
                const response = await fetch('/api/keymap/list');
                const data = await response.json();
                
                if (data.ok && data.keymaps) {
                    const customKeymaps = data.keymaps.filter(km => 
                        km !== 'jis.json' && km !== 'ansi.json' && km !== 'dvorak.json'
                    );
                    
                    if (customKeymaps.length > 0) {
                        const select = document.getElementById('keymap-select');
                        
                        // ã€Œã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
                        let hasCustomGroup = false;
                        for (let option of select.options) {
                            if (option.textContent === '--- ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ— ---') {
                                hasCustomGroup = true;
                                break;
                            }
                        }
                        
                        if (!hasCustomGroup && customKeymaps.length > 0) {
                            // ã‚°ãƒ«ãƒ¼ãƒ—ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿
                            const separator = document.createElement('option');
                            separator.textContent = '--- ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ— ---';
                            separator.disabled = true;
                            select.appendChild(separator);
                        }
                        
                        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã‚’è¿½åŠ 
                        customKeymaps.forEach(km => {
                            const keymapName = km.replace('.json', '');
                            const option = document.createElement('option');
                            option.value = keymapName;
                            option.textContent = `ğŸ“Œ ${keymapName}`;
                            select.appendChild(option);
                        });
                        
                        console.log(`âœ… Loaded ${customKeymaps.length} custom keymaps`);
                    }
                } else {
                    console.log('â„¹ï¸ No custom keymaps available');
                }
            } catch (error) {
                console.error('âŒ Error loading custom keymaps:', error);
            }
        }

        // ã‚­ãƒ¼ãƒãƒƒãƒ—é¸æŠã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('keymap-select').addEventListener('change', (e) => {
            const preset = e.target.value;
            loadKeymap(preset);
            
            // sessionStorage ã«ä¿å­˜
            safeSetStorage('selectedKeymap', preset);
            console.log('ğŸ’¾ Keymap saved to storage:', preset);
            
            const presetNames = {
                'jis': 'JISé…åˆ—',
                'ansi': 'ANSIé…åˆ—',
                'dvorak': 'Dvoraké…åˆ—'
            };
            document.getElementById('current-keymap-display').textContent = presetNames[preset] || preset;
            updateMappingPreview();
        });

        // ========== ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ã‚¯ã‚»ã‚¹é–¢æ•°ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¨ãƒ©ãƒ¼å¯¾å¿œï¼‰==========
        function safeGetStorage(key, defaultValue = null) {
            try {
                return sessionStorage.getItem(key) || defaultValue;
            } catch (error) {
                console.warn(`âš ï¸ sessionStorage access denied: ${error.message}, using default`);
                return defaultValue;
            }
        }

        function safeSetStorage(key, value) {
            try {
                sessionStorage.setItem(key, value);
                return true;
            } catch (error) {
                console.warn(`âš ï¸ sessionStorage write denied: ${error.message}`);
                return false;
            }
        }

        // åˆæœŸã‚­ãƒ¼ãƒãƒƒãƒ—èª­ã¿è¾¼ã¿
        loadKeymap('jis');
        
        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã‚’ã‚»ãƒ¬ã‚¯ãƒˆã«è¿½åŠ 
        loadCustomKeymaps();
        
        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ keymap ã‚’èª­ã¿è¾¼ã¿
        const savedKeymap = safeGetStorage('selectedKeymap');
        if (savedKeymap) {
            console.log('ğŸ’¾ Loading saved keymap:', savedKeymap);
            loadKeymap(savedKeymap);
            // setTimeout ã§ã‚»ãƒ¬ã‚¯ãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹ã¾ã§å¾…ã¤
            setTimeout(() => {
                document.getElementById('keymap-select').value = savedKeymap;
                updateMappingPreview();
            }, 100);
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿å¾©å…ƒ
        const savedKeymapData = safeGetStorage('currentKeymapData');
        if (savedKeymapData) {
            try {
                const parsed = JSON.parse(savedKeymapData);
                if (parsed.mappings && Object.keys(parsed.mappings).length > 0) {
                    keymapData = parsed;
                    updateMappingPreview();
                    console.log('ğŸ’¾ Restored keymap data from storage');
                }
            } catch (e) {
                console.warn('âš ï¸ Failed to restore keymap data:', e);
            }
        }

        // ========== ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç† ==========
        function updateMappingPreview() {
            const preview = document.getElementById('custom-mapping-preview');
            const mappings = keymapData?.mappings;
            
            if (mappings && Object.keys(mappings).length > 0) {
                preview.style.display = 'block';
                const previewMappings = document.getElementById('preview-mappings');
                previewMappings.innerHTML = Object.entries(mappings)
                    .slice(0, 5)
                    .map(([from, to]) => `
                        <span style="background: #ecf0f1; padding: 3px 8px; border-radius: 3px; font-size: 11px;">
                            <strong>${from}</strong> â†’ <strong>${to}</strong>
                        </span>
                    `).join('');
                
                if (Object.keys(mappings).length > 5) {
                    previewMappings.innerHTML += `<span style="font-size: 11px; color: #7f8c8d;">ä»– ${Object.keys(mappings).length - 5} å€‹</span>`;
                }
            } else {
                preview.style.display = 'none';
            }
        }

        // ãƒãƒƒãƒ”ãƒ³ã‚°ç·¨é›†UIè¡¨ç¤º
        function showMappingEditor() {
            const modal = document.getElementById('mapping-modal');
            const editItems = document.getElementById('edit-mapping-items');
            const mappings = keymapData?.mappings || {};
            
            if (Object.keys(mappings).length === 0) {
                editItems.innerHTML = '<p style="color: #999; text-align: center;">ãƒãƒƒãƒ”ãƒ³ã‚°ãªã—</p>';
            } else {
                editItems.innerHTML = Object.entries(mappings)
                    .map(([from, to]) => `
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-weight: bold; font-size: 14px;">${from}</span>
                                <span style="color: #95a5a6; margin: 0 8px;">â†’</span>
                                <span style="color: #27ae60; font-weight: bold; font-size: 14px; cursor: pointer; text-decoration: underline;" onclick="editMappingValue('${from}', '${to}')" title="ã‚¯ãƒªãƒƒã‚¯ã§å¤‰æ›´">${to}</span>
                            </div>
                            <button onclick="removeMapping('${from}')" style="padding: 4px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">
                                å‰Šé™¤
                            </button>
                        </div>
                    `).join('');
            }
            
            modal.style.display = 'block';
        }

        // ãƒãƒƒãƒ”ãƒ³ã‚°å€¤ã‚’ç·¨é›†
        function editMappingValue(from, to) {
            editingKey = from;
            editingValue = to;
            console.log(`âœï¸ Editing mapping: ${from} â†’ ${to}`);
            
            const editItems = document.getElementById('edit-mapping-items');
            editItems.innerHTML = `
                <div style="background: #fff3cd; padding: 12px; border-radius: 4px; border: 2px solid #f39c12;">
                    <p style="margin: 0 0 10px 0; font-weight: bold; color: #f39c12;">âŒ¨ï¸ \"${from}\" ã®æ–°ã—ã„å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„...</p>
                    <p style="margin: 0; font-size: 12px; color: #7f8c8d;">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ã‚­ãƒ¼ã‚’1ã¤æŠ¼ã—ã¦ãã ã•ã„</p>
                </div>
            `;
            
            // ã‚­ãƒ¼å…¥åŠ›å¾…æ©Ÿ (ä¸€åº¦ã ã‘)
            const handler = (e) => {
                e.preventDefault();
                const newValue = e.key;
                console.log(`âœ… New value captured: ${newValue}`);
                
                keymapData.mappings[from] = newValue;
                updateMappingPreview();
                
                // UIå†è¡¨ç¤º
                setTimeout(() => {
                    showMappingEditor();
                }, 100);
                
                document.removeEventListener('keydown', handler, true);
            };
            
            document.addEventListener('keydown', handler, true);
        }

        // ãƒãƒƒãƒ”ãƒ³ã‚°å‰Šé™¤
        function removeMapping(key) {
            delete keymapData.mappings[key];
            updateMappingPreview();
            showMappingEditor();
            console.log(`ğŸ—‘ï¸ Removed mapping: ${key}`);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('btn-edit-mapping').addEventListener('click', showMappingEditor);
        document.getElementById('btn-close-modal').addEventListener('click', () => {
            document.getElementById('mapping-modal').style.display = 'none';
            editingKey = null;
            editingValue = null;
        });

        console.log('  Target Rubi:', TARGET_RUBI);

        // ========== UIæ›´æ–°é–¢æ•° ==========
        function updateStats() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const total = correct + errors;
            const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;

            document.getElementById('stat-correct').textContent = correct;
            document.getElementById('stat-errors').textContent = errors;
            document.getElementById('stat-accuracy').textContent = accuracy + '%';
            document.getElementById('stat-time').textContent = elapsed + 's';
        }

        function showResultScreen(result) {
            console.log('ğŸ“Š Showing result screen:', result);
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const accuracy = result.accuracy || 0;

            document.getElementById('result-correct').textContent = result.correct || 0;
            document.getElementById('result-errors').textContent = result.errors || 0;
            document.getElementById('result-accuracy').textContent = accuracy + '%';
            document.getElementById('result-duration').textContent = elapsed + 'ç§’';

            // ç”»é¢åˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('typing-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.remove('hidden');
        }

        // ========== ã‚­ãƒ¼å…¥åŠ›å‡¦ç† ==========
        // ========== ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°å‡¦ç† ==========
        function applyKeyMapping(inputChar) {
            /**
             * ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’é©ç”¨
             * - currentKeymap ã« mappings ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
             * - ãªã„å ´åˆã¯å…ƒã®æ–‡å­—ã‚’è¿”ã™
             */
            if (!keymapData || !keymapData.mappings) {
                return inputChar;
            }

            const mappedChar = keymapData.mappings[inputChar];
            if (mappedChar) {
                console.log(`ğŸ”„ Keymap applied: ${inputChar} â†’ ${mappedChar}`);
                return mappedChar;
            }

            return inputChar;
        }

        document.getElementById('typing-input').addEventListener('keydown', async (e) => {
            let char = e.key;
            const input = document.getElementById('typing-input');

            // Backspaceå‡¦ç†
            if (e.key === 'Backspace') {
                e.preventDefault();
                input.value = input.value.slice(0, -1);
                return;
            }

            // Enterã‚­ãƒ¼ã§å®Œäº†
            if (e.key === 'Enter') {
                e.preventDefault();
                console.log('âœ… Enter pressed - finishing session');
                finishSession();
                return;
            }

            // åˆ¶å¾¡æ–‡å­—ã¯ç„¡è¦–
            if (e.ctrlKey || e.altKey || e.metaKey) return;

            // ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’é©ç”¨
            const mappedChar = applyKeyMapping(char);
            
            // é€šå¸¸ã®ã‚­ãƒ¼å…¥åŠ›
            console.log(`âŒ¨ï¸ Key pressed: ${char}${char !== mappedChar ? ` (mapped: ${mappedChar})` : ''}`);

            try {
                const timestamp = Date.now() - startTime;
                const response = await fetch(`/api/session/${SESSION_ID}/judge_char`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        char: mappedChar,  // ãƒãƒƒãƒ—ã•ã‚ŒãŸæ–‡å­—ã‚’é€ä¿¡
                        timestamp: timestamp,
                        keymap: currentKeymap
                    })
                });

                if (!response.ok) {
                    console.error('âŒ API error:', response.status);
                    return;
                }

                const data = await response.json();
                console.log('ğŸ“‹ Judge result:', data);

                if (data.ok) {
                    // çµæœã‚’åæ˜ 
                    if (data.result === 'correct') {
                        correct++;
                        console.log('âœ… Correct! Total:', correct);
                    } else {
                        errors++;
                        console.log('âŒ Error! Total:', errors);
                    }

                    // UIæ›´æ–°
                    updateStats();

                    // å®Œäº†ãƒã‚§ãƒƒã‚¯
                    if (data.finished) {
                        console.log('ğŸ‰ Session finished!');
                        showResultScreen(data);
                    } else if (data.progress !== undefined) {
                        // é€²æ—æ›´æ–°
                        let remainingRubi = '';
                        if (typeof data.progress === 'string') {
                            remainingRubi = data.progress;
                        } else if (data.progress.remaining_rubi !== undefined) {
                            remainingRubi = data.progress.remaining_rubi;
                        }
                        
                        currentProgress = remainingRubi;
                        document.getElementById('rubi-remaining').textContent = remainingRubi;
                        
                        const completedCount = TARGET_RUBI.length - remainingRubi.length;
                        document.getElementById('rubi-progress').textContent = `âœ… å…¥åŠ›æ¸ˆã¿: ${completedCount} æ–‡å­—`;
                        console.log('ğŸ“ Progress:', remainingRubi, `(Completed: ${completedCount}/${TARGET_RUBI.length})`);
                    }
                }
            } catch (error) {
                console.error('âŒ Error:', error);
            }
        });

        // ========== ãƒœã‚¿ãƒ³å‡¦ç† ==========
        async function finishSession() {
            try {
                const response = await fetch(`/api/session/${SESSION_ID}/finish`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();
                console.log('âœ… Finish response:', data);

                if (data.ok) {
                    showResultScreen(data);
                }
            } catch (error) {
                console.error('âŒ Finish error:', error);
            }
        }

        document.getElementById('btn-finish').addEventListener('click', () => {
            console.log('ğŸ”´ Finish button clicked');
            finishSession();
        });

        document.getElementById('btn-escape').addEventListener('click', () => {
            console.log('ğŸ”´ Escape button clicked');
            if (confirm('ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                window.location.href = '/';
            }
        });

        document.getElementById('btn-home').addEventListener('click', () => {
            console.log('ğŸ”´ Home button clicked');
            window.location.href = '/';
        });

        // åˆæœŸè¡¨ç¤º
        console.log('âœ… Typing page initialized');
    </script>
</body>
</html>

