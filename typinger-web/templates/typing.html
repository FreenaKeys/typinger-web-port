<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typinger - ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <h1>Typinger</h1>
            <p class="subtitle">Webç‰ˆ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ã‚½ãƒ•ãƒˆ</p>
        </header>

        <main>
            <!-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”»é¢ -->
            <section id="typing-screen" class="screen active">
                <div class="typing-container">
                    <!-- ã‚­ãƒ¼ãƒãƒƒãƒ—è¨­å®š + ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                    <div class="keymap-setting" style="margin-bottom: 20px; padding: 15px; background: #f0f0f0; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 15px;">
                            <div style="flex: 1;">
                                <label for="keymap-select" style="display: block; margin-bottom: 10px; font-weight: bold;">
                                    âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰é…åˆ—:
                                </label>
                                <select id="keymap-select" style="width: 100%; padding: 8px; font-size: 14px; border-radius: 4px;">
                                    <option value="jis">JISé…åˆ— (æ—¥æœ¬èª)</option>
                                    <option value="ansi">ANSIé…åˆ—</option>
                                    <option value="dvorak">Dvoraké…åˆ—</option>
                                </select>
                                <p id="keymap-info" style="margin-top: 10px; font-size: 12px; color: #666;">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: JISé…åˆ—</p>
                            </div>
                            <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                            <div id="custom-mapping-preview" style="flex: 0 0 auto; padding: 10px; background: white; border-radius: 4px; border: 1px solid #bdc3c7; min-width: 250px; max-width: 400px; display: none;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <p style="margin: 0; font-size: 11px; font-weight: bold; color: #2c3e50;">ğŸ¯ ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°</p>
                                    <button id="btn-toggle-mappings" style="padding: 3px 8px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 10px;">
                                        å±•é–‹
                                    </button>
                                </div>
                                <div id="preview-mappings-summary" style="font-size: 11px; color: #7f8c8d; margin-bottom: 8px;">
                                    <!-- ã‚µãƒãƒªãƒ¼è¡¨ç¤º -->
                                </div>
                                <div id="preview-mappings-detail" style="display: none; max-height: 300px; overflow-y: auto; margin-top: 10px;">
                                    <!-- è©³ç´°ãƒãƒƒãƒ”ãƒ³ã‚°ä¸€è¦§ -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ç›®æ¨™ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º -->
                    <div class="target-text-box">
                        <p class="label">ç›®æ¨™ãƒ†ã‚­ã‚¹ãƒˆ</p>
                        <p id="target-text" class="target-text">{{ target_text }}</p>
                    </div>

                    <!-- ãƒ«ãƒ“ï¼ˆãƒ­ãƒ¼ãƒå­—ï¼‰è¡¨ç¤º -->
                    <div class="rubi-box">
                        <p class="label">ãƒ­ãƒ¼ãƒå­—å…¥åŠ›</p>
                        <p id="rubi-remaining" class="rubi-remaining" style="min-height: 30px;">{{ target_rubi }}</p>
                        <p id="rubi-progress" style="font-size: 12px; color: #e74c3c; margin-top: 5px;"></p>
                    </div>

                    <!-- å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ -->
                    <div class="input-box">
                        <p style="font-size: 12px; color: #666; margin-bottom: 8px;">
                            ç¾åœ¨ã®ã‚­ãƒ¼ãƒãƒƒãƒ—: <span id="current-keymap-display">JISé…åˆ—</span>
                        </p>
                        <input type="text" id="typing-input" class="typing-input" placeholder="ã“ã“ã«å…¥åŠ›ã—ã¾ã™" autofocus>
                    </div>

                    <!-- çµ±è¨ˆæƒ…å ± -->
                    <div class="stats-box">
                        <table class="stats-table">
                            <tr>
                                <td>æ­£è§£:</td>
                                <td id="stat-correct">0</td>
                                <td>ãƒŸã‚¹:</td>
                                <td id="stat-errors">0</td>
                            </tr>
                            <tr>
                                <td>æˆåŠŸç‡:</td>
                                <td id="stat-accuracy">0%</td>
                                <td>çµŒéæ™‚é–“:</td>
                                <td id="stat-time">0s</td>
                            </tr>
                        </table>
                    </div>

                    <!-- æ“ä½œãƒœã‚¿ãƒ³ -->
                    <div class="button-box">
                        <button id="btn-finish" class="btn btn-primary">å®Œäº†</button>
                        <button id="btn-escape" class="btn btn-secondary">ä¸­æ­¢</button>
                    </div>
                </div>
            </section>

            <!-- çµæœç”»é¢ -->
            <section id="result-screen" class="screen hidden">
                <div class="typing-container">
                    <h2>å®Œäº†ã—ã¾ã—ãŸï¼</h2>
                    <div class="result-box">
                        <table class="result-table">
                            <tr>
                                <td>æ­£è§£æ•°:</td>
                                <td id="result-correct">0</td>
                            </tr>
                            <tr>
                                <td>ãƒŸã‚¹æ•°:</td>
                                <td id="result-errors">0</td>
                            </tr>
                            <tr>
                                <td>æˆåŠŸç‡:</td>
                                <td id="result-accuracy">0%</td>
                            </tr>
                            <tr>
                                <td>æ‰€è¦æ™‚é–“:</td>
                                <td id="result-duration">0ç§’</td>
                            </tr>
                        </table>
                    </div>
                    <div class="button-box">
                        <button id="btn-home" class="btn btn-primary">ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
                    </div>
                </div>
            </section>
        </main>

        <footer>
            <p>Typinger Webç‰ˆ - ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ã‚½ãƒ•ãƒˆ</p>
        </footer>
    </div>

    <script>
        // ========== ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ==========
        const SESSION_ID = '{{ session_id }}';
        const TARGET_TEXT = '{{ target_text }}';
        const TARGET_RUBI = '{{ target_rubi }}';
        
        let startTime = Date.now();
        let correct = 0;
        let errors = 0;
        let currentProgress = '';
        let currentKeymap = 'jis';
        let keymapData = null;
        let editingKey = null;
        let editingValue = null;

        console.log('ğŸ¬ Typing page loaded');
        console.log('  Session ID:', SESSION_ID);
        console.log('  Target Text:', TARGET_TEXT);
        console.log('  Target Rubi:', TARGET_RUBI);

        // ========== ã‚­ãƒ¼ãƒãƒƒãƒ—å‡¦ç† ==========
        async function loadKeymap(preset) {
            try {
                console.log(`âŒ¨ï¸ Loading keymap: ${preset}`);
                
                // ãƒ—ãƒªã‚»ãƒƒãƒˆã‹ã‚«ã‚¹ã‚¿ãƒ ã‹ã‚’åˆ¤å®š
                let response;
                if (['jis', 'ansi', 'dvorak'].includes(preset)) {
                    response = await fetch(`/api/keymap/presets/${preset}`);
                } else {
                    // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—
                    response = await fetch(`/api/keymap/${preset}`);
                }
                
                const data = await response.json();
                
                if (data.ok) {
                    keymapData = data.keymap;
                    
                    // mappings ãŒãªã„å ´åˆã¯åˆæœŸåŒ–
                    if (!keymapData.mappings) {
                        keymapData.mappings = {};
                    }
                    
                    currentKeymap = preset;
                    
                    const presetNames = {
                        'jis': 'JISé…åˆ— (æ—¥æœ¬èª)',
                        'ansi': 'ANSIé…åˆ—',
                        'dvorak': 'Dvoraké…åˆ—'
                    };
                    
                    const displayName = presetNames[preset] || preset;
                    document.getElementById('keymap-info').textContent = `âœ… ä½¿ç”¨ä¸­: ${displayName}`;
                    console.log(`âœ… Keymap loaded: ${preset}`, keymapData);
                } else {
                    console.error('âŒ Failed to load keymap:', data.error);
                }
            } catch (error) {
                console.error('âŒ Error loading keymap:', error);
            }
        }

        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã‚’ã‚»ãƒ¬ã‚¯ãƒˆã«è¿½åŠ 
        async function loadCustomKeymaps() {
            try {
                console.log('ğŸ“‚ Loading custom keymaps...');
                const response = await fetch('/api/keymap/list');
                const data = await response.json();
                
                if (data.ok && data.keymaps) {
                    const customKeymaps = data.keymaps.filter(km => 
                        km !== 'jis.json' && km !== 'ansi.json' && km !== 'dvorak.json'
                    );
                    
                    if (customKeymaps.length > 0) {
                        const select = document.getElementById('keymap-select');
                        
                        // ã€Œã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
                        let hasCustomGroup = false;
                        for (let option of select.options) {
                            if (option.textContent === '--- ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ— ---') {
                                hasCustomGroup = true;
                                break;
                            }
                        }
                        
                        if (!hasCustomGroup && customKeymaps.length > 0) {
                            // ã‚°ãƒ«ãƒ¼ãƒ—ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿
                            const separator = document.createElement('option');
                            separator.textContent = '--- ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ— ---';
                            separator.disabled = true;
                            select.appendChild(separator);
                        }
                        
                        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã‚’è¿½åŠ 
                        customKeymaps.forEach(km => {
                            const keymapName = km.replace('.json', '');
                            const option = document.createElement('option');
                            option.value = keymapName;
                            option.textContent = `ğŸ“Œ ${keymapName}`;
                            select.appendChild(option);
                        });
                        
                        console.log(`âœ… Loaded ${customKeymaps.length} custom keymaps`);
                    }
                } else {
                    console.log('â„¹ï¸ No custom keymaps available');
                }
            } catch (error) {
                console.error('âŒ Error loading custom keymaps:', error);
            }
        }

        // ã‚­ãƒ¼ãƒãƒƒãƒ—é¸æŠã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('keymap-select').addEventListener('change', (e) => {
            const preset = e.target.value;
            loadKeymap(preset);
            
            // sessionStorage ã«ä¿å­˜
            safeSetStorage('selectedKeymap', preset);
            console.log('ğŸ’¾ Keymap saved to storage:', preset);
            
            const presetNames = {
                'jis': 'JISé…åˆ—',
                'ansi': 'ANSIé…åˆ—',
                'dvorak': 'Dvoraké…åˆ—'
            };
            document.getElementById('current-keymap-display').textContent = presetNames[preset] || preset;
            updateMappingPreview();
        });

        // ========== ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ã‚¯ã‚»ã‚¹é–¢æ•°ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¨ãƒ©ãƒ¼å¯¾å¿œï¼‰==========
        function safeGetStorage(key, defaultValue = null) {
            try {
                return sessionStorage.getItem(key) || defaultValue;
            } catch (error) {
                console.warn(`âš ï¸ sessionStorage access denied: ${error.message}, using default`);
                return defaultValue;
            }
        }

        function safeSetStorage(key, value) {
            try {
                sessionStorage.setItem(key, value);
                return true;
            } catch (error) {
                console.warn(`âš ï¸ sessionStorage write denied: ${error.message}`);
                return false;
            }
        }

        // åˆæœŸã‚­ãƒ¼ãƒãƒƒãƒ—èª­ã¿è¾¼ã¿
        loadKeymap('jis');
        
        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ã‚’ã‚»ãƒ¬ã‚¯ãƒˆã«è¿½åŠ 
        loadCustomKeymaps();
        
        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ keymap ã‚’èª­ã¿è¾¼ã¿
        const savedKeymap = safeGetStorage('selectedKeymap');
        if (savedKeymap) {
            console.log('ğŸ’¾ Loading saved keymap:', savedKeymap);
            loadKeymap(savedKeymap);
            // setTimeout ã§ã‚»ãƒ¬ã‚¯ãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹ã¾ã§å¾…ã¤
            setTimeout(() => {
                document.getElementById('keymap-select').value = savedKeymap;
                updateMappingPreview();
            }, 100);
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿å¾©å…ƒ
        const savedKeymapData = safeGetStorage('currentKeymapData');
        if (savedKeymapData) {
            try {
                const parsed = JSON.parse(savedKeymapData);
                console.log('ğŸ’¾ Restored keymap data:', parsed);
                
                if (parsed.mappings && Object.keys(parsed.mappings).length > 0) {
                    // keymapData ã‚’å®Œå…¨ã«ç½®ãæ›ãˆã‚‹
                    if (!keymapData) {
                        keymapData = { version: 1, keys: [], mappings: {} };
                    }
                    keymapData.mappings = { ...parsed.mappings };
                    console.log('âœ… Applied mappings:', keymapData.mappings);
                    updateMappingPreview();
                }
            } catch (e) {
                console.warn('âš ï¸ Failed to restore keymap data:', e);
            }
        }
        
        // keymapData ã®ç¢ºèª
        console.log('ğŸ“Š Initial keymapData:', keymapData);

        // ========== ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç† ==========
        let mappingsExpanded = false;
        
        function updateMappingPreview() {
            const preview = document.getElementById('custom-mapping-preview');
            
            // keymapData ã®ç¢ºèª
            if (!keymapData) {
                console.warn('âš ï¸ keymapData is not initialized in updateMappingPreview');
                preview.style.display = 'none';
                return;
            }
            
            if (!keymapData.mappings) {
                keymapData.mappings = {};
            }
            
            const mappings = keymapData.mappings;
            const mappingCount = Object.keys(mappings).length;
            
            console.log(`ğŸ¯ updateMappingPreview called - ${mappingCount} mappings`);
            console.log('   Mappings:', mappings);
            
            if (mappingCount > 0) {
                console.log('âœ… Showing preview (has mappings)');
                preview.style.display = 'block';
                
                // ã‚µãƒãƒªãƒ¼è¡¨ç¤º
                const summaryEl = document.getElementById('preview-mappings-summary');
                summaryEl.textContent = `${mappingCount}å€‹ã®ãƒãƒƒãƒ”ãƒ³ã‚°`;
                
                // è©³ç´°ãƒªã‚¹ãƒˆç”Ÿæˆ
                const detailEl = document.getElementById('preview-mappings-detail');
                detailEl.innerHTML = Object.entries(mappings)
                    .map(([from, to]) => `
                        <div style="background: #f8f9fa; padding: 8px; border-radius: 3px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1; cursor: pointer;" onclick="window.editMappingValueInline('${from}', '${to}')">
                                <span style="font-weight: bold; font-size: 12px;">${from}</span>
                                <span style="color: #95a5a6; margin: 0 5px;">â†’</span>
                                <span style="color: #27ae60; font-weight: bold; font-size: 12px; text-decoration: underline;">${to}</span>
                            </div>
                            <button onclick="window.removeMappingInline('${from}')" style="padding: 2px 6px; background: #e74c3c; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 10px;">
                                å‰Šé™¤
                            </button>
                        </div>
                    `).join('');
                
            } else {
                preview.style.display = 'none';
            }
        }
        
        // å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿ãƒˆã‚°ãƒ«
        function toggleMappingsDetail() {
            mappingsExpanded = !mappingsExpanded;
            const detailEl = document.getElementById('preview-mappings-detail');
            const btnEl = document.getElementById('btn-toggle-mappings');
            
            if (mappingsExpanded) {
                detailEl.style.display = 'block';
                btnEl.textContent = 'æŠ˜ç•³';
            } else {
                detailEl.style.display = 'none';
                btnEl.textContent = 'å±•é–‹';
            }
        }
        
        // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§ãƒãƒƒãƒ”ãƒ³ã‚°ç·¨é›†
        function editMappingValueInline(from, to) {
            if (!keymapData) {
                console.error('âŒ keymapData is not initialized');
                alert('ã‚­ãƒ¼ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            editingKey = from;
            editingValue = to;
            console.log(`âœï¸ Editing mapping inline: ${from} â†’ ${to}`);
            
            const detailEl = document.getElementById('preview-mappings-detail');
            const tempHtml = detailEl.innerHTML;
            
            detailEl.innerHTML = `
                <div style="background: #fff3cd; padding: 12px; border-radius: 4px; border: 2px solid #f39c12; text-align: center;">
                    <p style="margin: 0 0 8px 0; font-weight: bold; color: #f39c12; font-size: 11px;">âŒ¨ï¸ "${from}" ã®æ–°ã—ã„å€¤ã‚’å…¥åŠ›...</p>
                    <p style="margin: 0; font-size: 10px; color: #7f8c8d;">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ã‚­ãƒ¼ã‚’1ã¤æŠ¼ã—ã¦ãã ã•ã„</p>
                </div>
            `;
            
            // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å…¥åŠ›ã‚’ãƒ–ãƒ©ãƒ¼
            const typingInput = document.getElementById('typing-input');
            if (typingInput) typingInput.blur();
            
            let handled = false;
            const handler = (e) => {
                if (handled) return;
                
                if (e.ctrlKey || e.altKey || e.metaKey) return;
                
                if (e.key === 'Escape') {
                    handled = true;
                    detailEl.innerHTML = tempHtml;
                    document.removeEventListener('keydown', handler, true);
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                handled = true;
                
                const newValue = e.key;
                console.log(`âœ… New value: "${newValue}"`);
                
                if (!keymapData.mappings) keymapData.mappings = {};
                keymapData.mappings[from] = newValue;
                
                console.log('âœ… Mapping updated:', keymapData.mappings);
                updateMappingPreview();
                
                document.removeEventListener('keydown', handler, true);
            };
            
            document.addEventListener('keydown', handler, true);
        }
        
        // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§ãƒãƒƒãƒ”ãƒ³ã‚°å‰Šé™¤
        function removeMappingInline(key) {
            console.log(`ğŸ—‘ï¸ Removing mapping inline: "${key}"`);
            delete keymapData.mappings[key];
            updateMappingPreview();
            console.log('âœ… Removed mapping:', key);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        const btnToggle = document.getElementById('btn-toggle-mappings');
        console.log('ğŸ” btn-toggle-mappings element:', btnToggle);
        if (btnToggle) {
            btnToggle.addEventListener('click', () => {
                console.log('ğŸ–±ï¸ Toggle button clicked!');
                toggleMappingsDetail();
            });
            console.log('âœ… Toggle button event listener registered');
        } else {
            console.error('âŒ btn-toggle-mappings element NOT FOUND!');
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢æ•°ã‚’ç™»éŒ²ï¼ˆonclick ã‹ã‚‰å‘¼ã³å‡ºã—å¯èƒ½ã«ã™ã‚‹ï¼‰
        window.editMappingValueInline = editMappingValueInline;
        window.removeMappingInline = removeMappingInline;
        window.toggleMappingsDetail = toggleMappingsDetail;
        console.log('âœ… Global functions registered:', {
            editMappingValueInline: typeof window.editMappingValueInline,
            removeMappingInline: typeof window.removeMappingInline,
            toggleMappingsDetail: typeof window.toggleMappingsDetail
        });

        console.log('  Target Rubi:', TARGET_RUBI);

        // ========== UIæ›´æ–°é–¢æ•° ==========
        function updateStats() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const total = correct + errors;
            const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;

            document.getElementById('stat-correct').textContent = correct;
            document.getElementById('stat-errors').textContent = errors;
            document.getElementById('stat-accuracy').textContent = accuracy + '%';
            document.getElementById('stat-time').textContent = elapsed + 's';
        }

        function showResultScreen(result) {
            console.log('ğŸ“Š Showing result screen:', result);
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const accuracy = result.accuracy || 0;

            document.getElementById('result-correct').textContent = result.correct || 0;
            document.getElementById('result-errors').textContent = result.errors || 0;
            document.getElementById('result-accuracy').textContent = accuracy + '%';
            document.getElementById('result-duration').textContent = elapsed + 'ç§’';

            // ç”»é¢åˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('typing-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.remove('hidden');
        }

        // ========== ã‚­ãƒ¼å…¥åŠ›å‡¦ç† ==========
        // ========== ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°å‡¦ç† ==========
        function applyKeyMapping(inputChar) {
            /**
             * ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’é©ç”¨
             * - currentKeymap ã« mappings ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
             * - ãªã„å ´åˆã¯å…ƒã®æ–‡å­—ã‚’è¿”ã™
             */
            if (!keymapData || !keymapData.mappings) {
                return inputChar;
            }

            const mappedChar = keymapData.mappings[inputChar];
            if (mappedChar) {
                console.log(`ğŸ”„ Keymap applied: ${inputChar} â†’ ${mappedChar}`);
                return mappedChar;
            }

            return inputChar;
        }

        document.getElementById('typing-input').addEventListener('keydown', async (e) => {
            let char = e.key;
            const input = document.getElementById('typing-input');

            // Backspaceå‡¦ç†
            if (e.key === 'Backspace') {
                e.preventDefault();
                input.value = input.value.slice(0, -1);
                return;
            }

            // Enterã‚­ãƒ¼ã§å®Œäº†
            if (e.key === 'Enter') {
                e.preventDefault();
                console.log('âœ… Enter pressed - finishing session');
                finishSession();
                return;
            }

            // åˆ¶å¾¡æ–‡å­—ã¯ç„¡è¦–
            if (e.ctrlKey || e.altKey || e.metaKey) return;

            // ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’é©ç”¨
            const mappedChar = applyKeyMapping(char);
            
            // é€šå¸¸ã®ã‚­ãƒ¼å…¥åŠ›
            console.log(`âŒ¨ï¸ Key pressed: ${char}${char !== mappedChar ? ` (mapped: ${mappedChar})` : ''}`);

            try {
                const timestamp = Date.now() - startTime;
                const response = await fetch(`/api/session/${SESSION_ID}/judge_char`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        char: mappedChar,  // ãƒãƒƒãƒ—ã•ã‚ŒãŸæ–‡å­—ã‚’é€ä¿¡
                        timestamp: timestamp,
                        keymap: currentKeymap
                    })
                });

                if (!response.ok) {
                    console.error('âŒ API error:', response.status);
                    return;
                }

                const data = await response.json();
                console.log('ğŸ“‹ Judge result:', data);

                if (data.ok) {
                    // çµæœã‚’åæ˜ 
                    if (data.result === 'correct') {
                        correct++;
                        console.log('âœ… Correct! Total:', correct);
                    } else {
                        errors++;
                        console.log('âŒ Error! Total:', errors);
                    }

                    // UIæ›´æ–°
                    updateStats();

                    // å®Œäº†ãƒã‚§ãƒƒã‚¯
                    if (data.finished) {
                        console.log('ğŸ‰ Session finished!');
                        showResultScreen(data);
                    } else if (data.progress !== undefined) {
                        // é€²æ—æ›´æ–°
                        let remainingRubi = '';
                        if (typeof data.progress === 'string') {
                            remainingRubi = data.progress;
                        } else if (data.progress.remaining_rubi !== undefined) {
                            remainingRubi = data.progress.remaining_rubi;
                        }
                        
                        currentProgress = remainingRubi;
                        document.getElementById('rubi-remaining').textContent = remainingRubi;
                        
                        const completedCount = TARGET_RUBI.length - remainingRubi.length;
                        document.getElementById('rubi-progress').textContent = `âœ… å…¥åŠ›æ¸ˆã¿: ${completedCount} æ–‡å­—`;
                        console.log('ğŸ“ Progress:', remainingRubi, `(Completed: ${completedCount}/${TARGET_RUBI.length})`);
                    }
                }
            } catch (error) {
                console.error('âŒ Error:', error);
            }
        });

        // ========== ãƒœã‚¿ãƒ³å‡¦ç† ==========
        async function finishSession() {
            try {
                const response = await fetch(`/api/session/${SESSION_ID}/finish`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();
                console.log('âœ… Finish response:', data);

                if (data.ok) {
                    showResultScreen(data);
                }
            } catch (error) {
                console.error('âŒ Finish error:', error);
            }
        }

        document.getElementById('btn-finish').addEventListener('click', () => {
            console.log('ğŸ”´ Finish button clicked');
            finishSession();
        });

        document.getElementById('btn-escape').addEventListener('click', () => {
            console.log('ğŸ”´ Escape button clicked');
            if (confirm('ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                window.location.href = '/';
            }
        });

        document.getElementById('btn-home').addEventListener('click', () => {
            console.log('ğŸ”´ Home button clicked');
            window.location.href = '/';
        });

        // åˆæœŸè¡¨ç¤º
        console.log('âœ… Typing page initialized');
    </script>
</body>
</html>

